package com.example.moneychanger.camera

import android.content.ContentValues
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.provider.MediaStore
import android.util.Log
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.CameraSelector
import androidx.camera.core.ImageCapture
import androidx.camera.core.ImageCaptureException
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import com.example.moneychanger.databinding.ActivityCameraBinding
import java.text.SimpleDateFormat
import java.util.Locale
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import android.Manifest
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import android.media.ExifInterface
import android.net.Uri
import android.view.View
import android.widget.FrameLayout
import androidx.camera.core.AspectRatio
import com.example.moneychanger.R
import com.example.moneychanger.etc.DataProvider
import com.example.moneychanger.etc.OnProductAddedListener
import com.example.moneychanger.etc.SlideCameraList
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.text.Text
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.korean.KoreanTextRecognizerOptions

class CameraActivity : AppCompatActivity(), OnProductAddedListener {
    private lateinit var binding: ActivityCameraBinding
    private lateinit var previewView: PreviewView
    private lateinit var captureButton: FrameLayout
    private lateinit var cameraExecutor: ExecutorService
    private var imageCapture: ImageCapture? = null
    private val selectedTexts = mutableListOf<String>() // ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ†ÌÉùÌïú ÌÖçÏä§Ìä∏ Ï†ÄÏû•

    private var selectedProductName: String? = null
    private var selectedProductPrice: String? = null
    private var isSelectingPrice = false // ÌòÑÏû¨ ÏÉÅÌíà Í∞ÄÍ≤© ÏÑ†ÌÉù Ï§ëÏù∏ÏßÄ ÌôïÏù∏ÌïòÎäî ÌîåÎûòÍ∑∏

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityCameraBinding.inflate(layoutInflater)
        setContentView(binding.root)

        previewView = binding.previewView
        captureButton = binding.cameraButton

        cameraExecutor = Executors.newSingleThreadExecutor()

        if (!hasCameraPermission()) {
            requestCameraPermission()
        } else {
            startCamera()
        }

        binding.listButton.setOnClickListener {
            val productList = DataProvider.productDummyModel  // ÎçîÎØ∏ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
            val slideCameraList = SlideCameraList.newInstance(productList)  // newInstance() ÏÇ¨Ïö©
            slideCameraList.show(supportFragmentManager, SlideCameraList.TAG)
        }

        captureButton.setOnClickListener {
            takePicture()
        }

    }

    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        cameraProviderFuture.addListener({
            val cameraProvider = cameraProviderFuture.get()

            cameraProvider.unbindAll()

            val preview = Preview.Builder()
                .setTargetAspectRatio(AspectRatio.RATIO_16_9) // üìå ÌôîÎ©¥ ÎπÑÏú®ÏùÑ 16:9Î°ú ÏÑ§Ï†ï
                .build()
                .also {
                    it.setSurfaceProvider(previewView.surfaceProvider)
                }

            imageCapture = ImageCapture.Builder()
                .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
                .setTargetAspectRatio(AspectRatio.RATIO_16_9) // üìå ÏÇ¨ÏßÑ Ï¥¨ÏòÅ ÎπÑÏú®ÏùÑ 16:9Î°ú ÏÑ§Ï†ï
                .build()


            val cameraSelector = CameraSelector.Builder()
                .requireLensFacing(CameraSelector.LENS_FACING_BACK)
                .build()

            try{
                Log.v("CameraActivity", "startCamera.try")
                cameraProvider.bindToLifecycle(this, cameraSelector, preview, imageCapture)
            }catch (exc:Exception){
                Log.e("CameraActivity", "Use case binding failed", exc)
            }
        }, ContextCompat.getMainExecutor(this))
    }

    private fun takePicture() {
        val imageCapture = imageCapture ?: return
        val name = SimpleDateFormat(FILENAME_FORMAT, Locale.US).format(System.currentTimeMillis())

        val contentValues = ContentValues().apply {
            put(MediaStore.MediaColumns.DISPLAY_NAME, name)
            put(MediaStore.MediaColumns.MIME_TYPE, "image/jpeg")
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                put(MediaStore.Images.Media.RELATIVE_PATH, "Pictures/CameraX-Image")
            }
        }

        val outputOptions = ImageCapture.OutputFileOptions.Builder(
            contentResolver,
            MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
            contentValues
        ).build()

        imageCapture.takePicture(
            outputOptions,
            ContextCompat.getMainExecutor(this),
            object : ImageCapture.OnImageSavedCallback {
                override fun onError(exc: ImageCaptureException) {
                    Log.e("CameraActivity", "ÏÇ¨ÏßÑ Ï∫°Ï≤ò Ïã§Ìå®: ${exc.message}", exc)
                }

                override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                    val savedUri = output.savedUri ?: return
                    Log.d("CameraActivity", "ÏÇ¨ÏßÑ Ï†ÄÏû•Îê®: $savedUri")
//                    Toast.makeText(baseContext, "Photo : ${output.savedUri}", Toast.LENGTH_SHORT).show()

                    // ÎπÑÌä∏Îßµ Î∂àÎü¨Ïò§Î©¥ÏÑú EXIF ÌöåÏ†Ñ Ï†ÅÏö©
                    val bitmap = loadBitmapWithRotation(savedUri)

                    runOnUiThread {
                        binding.capturedImageView.setImageBitmap(bitmap) // Ïò¨Î∞îÎ•¥Í≤å ÌöåÏ†ÑÎêú Ïù¥ÎØ∏ÏßÄ ÌëúÏãú
                        binding.previewView.visibility = View.INVISIBLE
                        binding.capturedImageView.visibility = View.VISIBLE
                    }

                    // OCR Ïã§Ìñâ
                    recognizeTextFromBitmap(bitmap)
                }
            }
        )
    }

    private fun loadBitmapWithRotation(uri: Uri): Bitmap {
        val inputStream = contentResolver.openInputStream(uri)
        val bitmap = BitmapFactory.decodeStream(inputStream)

        // ExifInterfaceÎ•º ÏÇ¨Ïö©Ìï¥ ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄÏùò ÌöåÏ†Ñ Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§Í∏∞
        val exif = ExifInterface(contentResolver.openInputStream(uri)!!)
        val rotation = when (exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL)) {
            ExifInterface.ORIENTATION_ROTATE_90 -> 90
            ExifInterface.ORIENTATION_ROTATE_180 -> 180
            ExifInterface.ORIENTATION_ROTATE_270 -> 270
            else -> 0
        }

        return if (rotation != 0) {
            rotateBitmap(bitmap, rotation)
        } else {
            bitmap
        }
    }

    private fun rotateBitmap(bitmap: Bitmap, degree: Int): Bitmap {
        val matrix = Matrix().apply { postRotate(degree.toFloat()) }
        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)
    }

    private fun hasCameraPermission(): Boolean {
        return ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED
    }

    private fun requestCameraPermission() {
        ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), CAMERA_PERMISSION_CODE)
    }

    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == CAMERA_PERMISSION_CODE) {
            if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                startCamera()
            } else {
                Toast.makeText(this, "Ïπ¥Î©îÎùº Í∂åÌïúÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.", Toast.LENGTH_LONG).show()
            }
        }
    }

    private fun recognizeTextFromBitmap(bitmap: Bitmap) {
        val image = InputImage.fromBitmap(bitmap, 0)
        val recognizer = TextRecognition.getClient(KoreanTextRecognizerOptions.Builder().build())

        recognizer.process(image)
            .addOnSuccessListener { visionText ->
                displayRecognizedText(visionText, bitmap) // ÎπÑÌä∏Îßµ Í∏∞Ï§ÄÏúºÎ°ú OCR Î∞ïÏä§ ÏÉùÏÑ±
            }
            .addOnFailureListener { e ->
                Log.e("OCR", "ÌÖçÏä§Ìä∏ Ïù∏Ïãù Ïã§Ìå®: ${e.localizedMessage}")
                Toast.makeText(this, "ÌÖçÏä§Ìä∏ Ïù∏Ïãù Ïã§Ìå®", Toast.LENGTH_SHORT).show()
            }
    }

    private fun displayRecognizedText(visionText: Text, bitmap: Bitmap) {
        binding.textOverlay.removeAllViews()
        selectedTexts.clear()

        binding.capturedImageView.post {
            val displayedWidth = binding.capturedImageView.width.toFloat()
            val displayedHeight = binding.capturedImageView.height.toFloat()

            val originalWidth = bitmap.width.toFloat()
            val originalHeight = bitmap.height.toFloat()

            // OCR Î∞ïÏä§ ÌÅ¨Í∏∞ Ï°∞Ï†ï (Ïù¥ÎØ∏ÏßÄÏùò Ïã§Ï†ú ÎπÑÏú®Ïóê ÎßûÏ∂∞ Î≥¥Ï†ï)
            val scaleX = displayedWidth / originalWidth
            val scaleY = displayedHeight / originalHeight

            val offsetX = (displayedWidth - (originalWidth * scaleX)) / 2
            val offsetY = (displayedHeight - (originalHeight * scaleY)) / 2

            Log.d("OCR", "üîç Scale Factor: X=$scaleX, Y=$scaleY, OffsetX: $offsetX, OffsetY: $offsetY")

            for (block in visionText.textBlocks) {
                for (line in block.lines) {
                    val rect = line.boundingBox ?: continue
                    val angle = line.angle  // ML KitÏù¥ Í∞êÏßÄÌïú ÌöåÏ†Ñ Í∞ÅÎèÑ (Í∏∞Ïö∏Ïñ¥ÏßÑ ÌÖçÏä§Ìä∏)

                    // Î∞ïÏä§ ÌÅ¨Í∏∞ Î≥¥Ï†ï (ÏïΩÍ∞ÑÏùò padding Ï∂îÍ∞Ä)
                    val boxPadding = 4  // 4px Ìå®Îî© Ï∂îÍ∞Ä
                    val adjustedWidth = (rect.width() * scaleX + boxPadding).toInt()
                    val adjustedHeight = (rect.height() * scaleY + boxPadding).toInt()

                    val borderView = View(this@CameraActivity).apply {
                        setBackgroundResource(R.drawable.ocr_border)
                        isClickable = true
                        rotation = angle  // Í∏∞Ïö∏Ïñ¥ÏßÑ ÌÖçÏä§Ìä∏ Í∞ÅÎèÑÎ•º OCR Î∞ïÏä§Ïóê Ï†ÅÏö©
                        setOnClickListener { toggleSelection(this, line.text) }
                    }

                    val layoutParams = FrameLayout.LayoutParams(adjustedWidth, adjustedHeight).apply {
                        leftMargin = (rect.left * scaleX + offsetX - boxPadding / 2).toInt()
                        topMargin = (rect.top * scaleY + offsetY - boxPadding / 2).toInt()
                    }

                    binding.textOverlay.addView(borderView, layoutParams)
                }
            }

            binding.textOverlay.visibility = View.VISIBLE
            Toast.makeText(this@CameraActivity, "ÏÉÅÌíàÎ™ÖÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.", Toast.LENGTH_SHORT).show()
        }
    }

    private fun toggleSelection(view: View, text: String) {
        if (selectedTexts.contains(text)) {
            // Ïù¥ÎØ∏ ÏÑ†ÌÉùÎêú Ìï≠Î™©ÏùÑ ÌÅ¥Î¶≠ÌïòÎ©¥ ÏÑ†ÌÉù Ìï¥Ï†ú
            selectedTexts.remove(text)
            view.setBackgroundResource(R.drawable.ocr_border) // Í∏∞Î≥∏ ÌÖåÎëêÎ¶¨Î°ú Î≥ÄÍ≤Ω

            if (selectedProductName == text) {
                selectedProductName = null
                isSelectingPrice = false
                Toast.makeText(this, "ÏÉÅÌíàÎ™ÖÏù¥ ÏÑ†ÌÉù Ìï¥Ï†úÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.", Toast.LENGTH_SHORT).show()
            } else if (selectedProductPrice == text) {
                selectedProductPrice = null
                isSelectingPrice = true // Í∞ÄÍ≤© ÏÑ†ÌÉù ÏÉÅÌÉúÎ•º Îã§Ïãú ÌôúÏÑ±Ìôî
                Toast.makeText(this, "ÏÉÅÌíà Í∞ÄÍ≤©Ïù¥ ÏÑ†ÌÉù Ìï¥Ï†úÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.", Toast.LENGTH_SHORT).show()
            }
            return
        }

        // ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏùÄ Ìï≠Î™©ÏùÑ ÌÅ¥Î¶≠Ìïú Í≤ΩÏö∞
        selectedTexts.add(text)
        view.setBackgroundResource(R.drawable.ocr_border_selected) // ÏÑ†ÌÉùÎêú ÏÉÅÌÉú

        if (selectedProductName == null) {
            // ÏÉÅÌíàÎ™ÖÏùÑ ÏÑ†ÌÉùÌïòÎäî Îã®Í≥Ñ (Ïà´ÏûêÍ∞Ä Ìè¨Ìï®Îêú ÌÖçÏä§Ìä∏Îäî ÏÉÅÌíàÎ™ÖÏù¥ ÏïÑÎãê ÌôïÎ•†Ïù¥ ÎÜíÏùå)
            if (text.any { it.isDigit() }) {
                Toast.makeText(this, "ÏûòÎ™ªÎêú ÏÑ†ÌÉùÏûÖÎãàÎã§. ÏÉÅÌíàÎ™ÖÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.", Toast.LENGTH_SHORT).show()
                return
            }
            selectedProductName = text
            isSelectingPrice = true
            Toast.makeText(this, "ÏÉÅÌíà Í∞ÄÍ≤©ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.", Toast.LENGTH_SHORT).show()
        } else {
            // ÏÉÅÌíà Í∞ÄÍ≤©ÏùÑ ÏÑ†ÌÉùÌïòÎäî Îã®Í≥Ñ
            val cleanPrice = cleanPriceText(text)

            if (cleanPrice.isEmpty()) {
                Toast.makeText(this, "ÏûòÎ™ªÎêú ÏÑ†ÌÉùÏûÖÎãàÎã§. Ïà´ÏûêÎ°ú Îêú Í∞ÄÍ≤©ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.", Toast.LENGTH_SHORT).show()
                return
            }

            // Í∏∞Ï°¥Ïóê ÏÑ†ÌÉùÎêú Í∞ÄÍ≤©Ïù¥ ÏûàÏúºÎ©¥ Ìï¥Ï†úÌïòÍ≥† ÏÉàÎ°úÏö¥ Í∞ÄÍ≤© ÏÑ†ÌÉù
            if (selectedProductPrice != null) {
                selectedTexts.remove(selectedProductPrice) // UIÏóêÏÑú ÏÑ†ÌÉù Ìï¥Ï†ú
            }

            selectedProductPrice = text
            updateSelectedText()
        }
    }

    private fun cleanPriceText(priceText: String): String {
        val cleaned = priceText.replace(Regex("[^0-9.]"), "") // Ïà´ÏûêÏôÄ ÏÜåÏàòÏ†êÎßå ÎÇ®ÍπÄ
        return if (cleaned.matches(Regex("\\d+(\\.\\d+)?"))) cleaned else ""
    }

    private fun updateSelectedText() {
        if (selectedProductName != null && selectedProductPrice != null) {
            val cleanPrice = cleanPriceText(selectedProductPrice!!)
            val resultText = "ÏÉÅÌíàÎ™Ö: ${selectedProductName}, ÏÉÅÌíàÍ∞ÄÍ≤©: ${cleanPrice}"
            binding.cameraText.text = resultText
            Toast.makeText(this, "ÏÑ†ÌÉù ÏôÑÎ£å: $resultText", Toast.LENGTH_SHORT).show()
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor.shutdown()
    }

    companion object {
        private const val TAG = "CameraXApp"
        private const val FILENAME_FORMAT = "yyyy-MM-dd-HH-mm-ss-SSS"
        private const val CAMERA_PERMISSION_CODE: Int = 10

    }

    override fun onProductAdded(productName: String, price: Double) {
        Log.d("CameraActivity", "ÏÉÅÌíàÎ™Ö: $productName, Í∞ÄÍ≤©: $price")
    }

}